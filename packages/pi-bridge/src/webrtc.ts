/**
 * WebRTC Streaming Module
 * 
 * Manages go2rtc binary for low-latency WebRTC streaming.
 * go2rtc converts RTSP streams to WebRTC, providing sub-second latency
 * compared to several seconds with HLS.
 */

import { spawn, ChildProcess } from 'child_process';
import { existsSync, mkdirSync, writeFileSync, chmodSync, createWriteStream, unlinkSync } from 'fs';
import { join } from 'path';
import { homedir, platform, arch } from 'os';
import { pipeline } from 'stream/promises';

const GO2RTC_VERSION = '1.9.4';
const GO2RTC_DIR = join(homedir(), '.birdcam', 'go2rtc');
const GO2RTC_BIN = join(GO2RTC_DIR, platform() === 'win32' ? 'go2rtc.exe' : 'go2rtc');
const GO2RTC_CONFIG = join(GO2RTC_DIR, 'go2rtc.yaml');
const GO2RTC_API_PORT = 1984;

let go2rtcProcess: ChildProcess | null = null;
let isRunning = false;
let currentRtspUrl: string | null = null;

interface Go2rtcConfig {
  api: {
    listen: string;
  };
  streams: {
    [key: string]: string;
  };
  webrtc?: {
    candidates?: string[];
  };
}

/**
 * Get the download URL for go2rtc binary based on platform
 */
function getDownloadUrl(): string {
  const os = platform();
  const architecture = arch();
  
  let osName: string;
  let archName: string;
  let ext = '';
  
  // Map Node.js platform to go2rtc naming
  switch (os) {
    case 'linux':
      osName = 'linux';
      break;
    case 'darwin':
      osName = 'mac';
      break;
    case 'win32':
      osName = 'win64';
      ext = '.exe';
      break;
    default:
      throw new Error(`Unsupported platform: ${os}`);
  }
  
  // Map architecture
  switch (architecture) {
    case 'arm64':
      archName = 'arm64';
      break;
    case 'arm':
      archName = 'arm';
      break;
    case 'x64':
      archName = 'amd64';
      break;
    default:
      throw new Error(`Unsupported architecture: ${architecture}`);
  }
  
  // go2rtc releases format: go2rtc_linux_arm64
  const filename = `go2rtc_${osName}_${archName}${ext}`;
  return `https://github.com/AlexxIT/go2rtc/releases/download/v${GO2RTC_VERSION}/${filename}`;
}

/**
 * Download go2rtc binary if not present
 */
export async function ensureGo2rtc(): Promise<boolean> {
  // Create directory if needed
  if (!existsSync(GO2RTC_DIR)) {
    mkdirSync(GO2RTC_DIR, { recursive: true });
  }
  
  // Check if binary exists
  if (existsSync(GO2RTC_BIN)) {
    console.log('[WebRTC] go2rtc binary found');
    return true;
  }
  
  console.log('[WebRTC] Downloading go2rtc...');
  
  try {
    const url = getDownloadUrl();
    console.log(`[WebRTC] Download URL: ${url}`);
    
    // Use dynamic import for node-fetch (ESM)
    const fetch = (await import('node-fetch')).default;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Download failed: ${response.status} ${response.statusText}`);
    }
    
    // Stream to file
    const fileStream = createWriteStream(GO2RTC_BIN);
    await pipeline(response.body as any, fileStream);
    
    // Make executable on Unix
    if (platform() !== 'win32') {
      chmodSync(GO2RTC_BIN, 0o755);
    }
    
    console.log('[WebRTC] go2rtc downloaded successfully');
    return true;
  } catch (err) {
    console.error('[WebRTC] Failed to download go2rtc:', (err as Error).message);
    return false;
  }
}

/**
 * Generate go2rtc configuration YAML
 */
function generateConfig(rtspUrl: string): string {
  const config: Go2rtcConfig = {
    api: {
      listen: `:${GO2RTC_API_PORT}`,
    },
    streams: {
      birdcam: rtspUrl,
    },
    webrtc: {
      // Add STUN servers for NAT traversal
      candidates: [
        'stun:stun.l.google.com:19302',
      ],
    },
  };
  
  // Convert to YAML (simple format since our config is straightforward)
  const yaml = `# go2rtc config - auto-generated by BirdCam Pi Bridge
api:
  listen: ":${GO2RTC_API_PORT}"

streams:
  birdcam: "${rtspUrl}"

webrtc:
  candidates:
    - stun:stun.l.google.com:19302
`;
  
  return yaml;
}

/**
 * Start go2rtc process
 */
export async function startGo2rtc(rtspUrl: string): Promise<boolean> {
  if (isRunning) {
    console.log('[WebRTC] go2rtc already running');
    return true;
  }
  
  // Ensure binary exists
  const hasBinary = await ensureGo2rtc();
  if (!hasBinary) {
    console.error('[WebRTC] Cannot start without go2rtc binary');
    return false;
  }
  
  currentRtspUrl = rtspUrl;
  
  // Write config
  const configYaml = generateConfig(rtspUrl);
  writeFileSync(GO2RTC_CONFIG, configYaml);
  console.log('[WebRTC] Config written to', GO2RTC_CONFIG);
  
  return new Promise((resolve) => {
    console.log('[WebRTC] Starting go2rtc...');
    
    go2rtcProcess = spawn(GO2RTC_BIN, ['-config', GO2RTC_CONFIG], {
      stdio: ['ignore', 'pipe', 'pipe'],
    });
    
    let started = false;
    
    go2rtcProcess.stdout?.on('data', (data) => {
      const output = data.toString();
      if (process.env.DEBUG === 'true') {
        console.log('[go2rtc]', output.trim());
      }
      
      // Check for successful startup
      if (!started && (output.includes('api') || output.includes('listen'))) {
        started = true;
        isRunning = true;
        console.log(`[WebRTC] go2rtc running on port ${GO2RTC_API_PORT}`);
        resolve(true);
      }
    });
    
    go2rtcProcess.stderr?.on('data', (data) => {
      const output = data.toString().trim();
      if (output) {
        console.error('[go2rtc error]', output);
      }
    });
    
    go2rtcProcess.on('error', (err) => {
      console.error('[WebRTC] Failed to start go2rtc:', err.message);
      isRunning = false;
      resolve(false);
    });
    
    go2rtcProcess.on('exit', (code) => {
      console.log(`[WebRTC] go2rtc exited with code ${code}`);
      isRunning = false;
      go2rtcProcess = null;
    });
    
    // Timeout - resolve true anyway since go2rtc may not output anything on success
    setTimeout(() => {
      if (!started) {
        started = true;
        isRunning = true;
        console.log(`[WebRTC] go2rtc started (assumed) on port ${GO2RTC_API_PORT}`);
        resolve(true);
      }
    }, 3000);
  });
}

/**
 * Stop go2rtc process
 */
export function stopGo2rtc(): void {
  if (go2rtcProcess) {
    console.log('[WebRTC] Stopping go2rtc...');
    go2rtcProcess.kill('SIGTERM');
    go2rtcProcess = null;
    isRunning = false;
  }
}

/**
 * Check if go2rtc is running
 */
export function isGo2rtcRunning(): boolean {
  return isRunning;
}

/**
 * Get go2rtc API port
 */
export function getGo2rtcApiPort(): number {
  return GO2RTC_API_PORT;
}

// WebRTC signaling types (browser types, we just proxy them as objects)
interface WebRTCSessionDescription {
  type: string;
  sdp: string;
}

interface WebRTCIceCandidate {
  candidate?: string;
  sdpMid?: string;
  sdpMLineIndex?: number;
}

/**
 * Get WebRTC offer from go2rtc
 * Proxies the WebRTC signaling exchange
 */
export async function getWebRTCOffer(offer: WebRTCSessionDescription): Promise<WebRTCSessionDescription | null> {
  if (!isRunning) {
    console.error('[WebRTC] go2rtc not running');
    return null;
  }
  
  try {
    const fetch = (await import('node-fetch')).default;
    
    // go2rtc WebRTC API endpoint
    const url = `http://127.0.0.1:${GO2RTC_API_PORT}/api/webrtc?src=birdcam`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(offer),
    });
    
    if (!response.ok) {
      throw new Error(`go2rtc API error: ${response.status}`);
    }
    
    const answer = await response.json() as WebRTCSessionDescription;
    return answer;
  } catch (err) {
    console.error('[WebRTC] Failed to get offer:', (err as Error).message);
    return null;
  }
}

/**
 * Get ICE candidates from go2rtc (for trickle ICE)
 */
export async function addIceCandidate(candidate: WebRTCIceCandidate): Promise<boolean> {
  if (!isRunning) {
    return false;
  }
  
  try {
    const fetch = (await import('node-fetch')).default;
    
    const url = `http://127.0.0.1:${GO2RTC_API_PORT}/api/webrtc?src=birdcam`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(candidate),
    });
    
    return response.ok;
  } catch (err) {
    console.error('[WebRTC] Failed to add ICE candidate:', (err as Error).message);
    return false;
  }
}

/**
 * Proxy any request to go2rtc API
 */
export async function proxyToGo2rtc(path: string, method: string, body?: any): Promise<any> {
  if (!isRunning) {
    throw new Error('go2rtc not running');
  }
  
  const fetch = (await import('node-fetch')).default;
  
  const url = `http://127.0.0.1:${GO2RTC_API_PORT}${path}`;
  
  const options: any = {
    method,
    headers: {},
  };
  
  if (body) {
    options.headers['Content-Type'] = 'application/json';
    options.body = JSON.stringify(body);
  }
  
  const response = await fetch(url, options);
  
  if (!response.ok) {
    throw new Error(`go2rtc API error: ${response.status}`);
  }
  
  const contentType = response.headers.get('content-type');
  if (contentType?.includes('application/json')) {
    return response.json();
  }
  
  return response.text();
}
